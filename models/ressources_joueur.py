from typing import Dict
from repositories.depot_batiment import DepotBatiment
from utils.constantes import *
from utils.catalogue_prix import CataloguePrix
from utils.generateur_identifiant import generer_identifiant
from utils.mode_selection import ModeSelection

class RessourceJoueur:
    """
    Classe repr√©sentant les ressources poss√©d√©es par un joueur, incluant argent,
    graines, animaux, b√¢timents, techniciens, eau, nourriture pour b√©tails et m√©dicaments.

    Attributes:
        identifiant (str): Identifiant unique du joueur.
        argent (float): Montant d'argent disponible.
        medicaments (int): Nombre de m√©dicaments.
        eau (float): Quantit√© d'eau disponible.
        nourriture_betails (int): Quantit√© de nourriture pour le b√©tail.
        catalogue_prix (CataloguePrix): Catalogue des prix des ressources.
        graines (dict): Quantit√© de graines pour chaque culture.
        animaux (dict): Nombre d'animaux pour chaque type.
        batiments (dict): Nombre de b√¢timents pour chaque type.
        production_batiments (dict): Production quotidienne par b√¢timent.
        techniciens (dict): Nombre de techniciens par m√©tier.
    """
    
    def __init__(self, identifiant: str, argent: float = 1500, medicaments: int = 0, 
                 graines: Dict[str, int] = None, animaux: Dict[str, int] = None,
                 batiments: Dict[str, int] = None, production_batiments: Dict[str, int] = None, 
                 techniciens: Dict[str, int] = None, eau: float = 100000.0, 
                 nourriture_betails: int = 200):
        """
        Initialise les ressources du joueur avec des valeurs par d√©faut ou fournies.

        Args:
            identifiant (str): Identifiant unique du joueur.
            argent (float, optional): Montant initial d'argent. Par d√©faut 1500.
            medicaments (int, optional): Quantit√© initiale de m√©dicaments. Par d√©faut 0.
            graines (dict, optional): Quantit√© initiale de chaque graine. Par d√©faut valeurs par d√©faut.
            animaux (dict, optional): Quantit√© initiale de chaque animal. Par d√©faut valeurs par d√©faut.
            batiments (dict, optional): Quantit√© initiale de chaque b√¢timent. Par d√©faut valeurs par d√©faut.
            production_batiments (dict, optional): Production initiale par b√¢timent. Par d√©faut valeurs par d√©faut.
            techniciens (dict, optional): Nombre initial de techniciens. Par d√©faut valeurs par d√©faut.
            eau (float, optional): Quantit√© initiale d'eau. Par d√©faut 100000.0.
            nourriture_betails (int, optional): Quantit√© initiale de nourriture pour b√©tail. Par d√©faut 200.
        """
        self.identifiant = identifiant
        self.argent = argent
        self.medicaments = medicaments
        self.eau = eau
        self.nourriture_betails = nourriture_betails
        self.catalogue_prix = CataloguePrix()

        if graines is not None:
            self.graines = graines
        else:
            self.graines = {nom: 0 for nom in NOMS_CULTURES}
            self.graines["bl√©"] = 5
            self.graines["carotte"] = 5
            self.graines["ma√Øs"] = 5

        if animaux is not None:
            self.animaux = animaux
        else:
            self.animaux = {nom: 0 for nom in NOMS_ANIMAUX}
            self.animaux["poule"] = 3
            self.animaux["mouton"] = 2            
            self.animaux["vache"] = 1

        if batiments is not None:
            self.batiments = batiments
        else:
            self.batiments = {nom: 0 for nom in NOMS_BATIMENTS}
            self.batiments["poulailler"] = 2
            self.batiments["√©table"] = 1
            self.batiments["laiterie"] = 1

        if production_batiments is not None:
            self.production_batiments = production_batiments
        else:
            self.production_batiments = {nom: 0 for nom in NOMS_PRODUCTION_BATIMENTS}
            self.production_batiments["oeuf"] = 30
            self.production_batiments["laine"] = 50
            self.production_batiments["lait"] = 20

        if techniciens is not None:
            self.techniciens = techniciens
        else:
            self.techniciens = {nom: 0 for nom in NOMS_TECHNICIENS}
            self.techniciens["m√©canicien"] = 1
            self.techniciens["plombier"] = 1
            self.techniciens["√©lectricien"] = 1        
            
    def _acheter(self, nom: str, prix: float, type_de_ressources: dict = None, quantite: int = 1,
                  effet=None, repo=None):
        """
        Ach√®te une ressource g√©n√©rique si le joueur a assez d'argent.

        Args:
            nom (str): Nom de la ressource √† acheter.
            prix (float): Prix unitaire de la ressource.
            type_de_ressources (dict, optional): Dictionnaire o√π incr√©menter la ressource achet√©e.
            quantite (int, optional): Quantit√© √† acheter. Par d√©faut 1.
            effet (callable, optional): Effet sp√©cial √† appliquer apr√®s achat.
            repo (object, optional): D√©p√¥t pour mettre √† jour l'√©tat des ressources.
        """
        if self.argent >= prix * quantite:
            self.argent -= prix * quantite
            if type_de_ressources is not None:
                type_de_ressources[nom] += quantite
            if effet:
                effet()  # pour cas sp√©ciaux : eau, etc.
            if repo is not None:
                repo.ajouter(self)
            print(f"Achat r√©ussi : {nom} (+{quantite}) pour {prix * quantite}‚Ç¨")
        else:
            print(f"Pas assez d'argent pour acheter {nom}.")

    def _vendre(self, case, mode: ModeSelection, repo_cultures, repo_animaux, repo_cases, repo_ressources_joueur):
        """
        Vend une culture ou un animal mature selon le mode de s√©lection.

        Args:
            case (object): Case contenant l'√©l√©ment √† vendre.
            mode (ModeSelection): Mode de vente (CULTURE ou ANIMAL).
            repo_cultures (object): D√©p√¥t des cultures.
            repo_animaux (object): D√©p√¥t des animaux.
            repo_cases (object): D√©p√¥t des cases.
            repo_ressources_joueur (object): D√©p√¥t pour mettre √† jour les ressources du joueur.
        """        
        if mode == ModeSelection.CULTURE and case.id_culture:
            element = repo_cultures.trouver_par_id(case.id_culture)
            age_max = element.temps_pousse() if element else 0
            repo = repo_cultures
            id_attr = "id_culture"
        elif mode == ModeSelection.ANIMAL and case.id_animal:
            element = repo_animaux.trouver_par_id(case.id_animal)
            age_max = element.temps_croissance() if element else 0
            repo = repo_animaux
            id_attr = "id_animal"
        else:
            return  # Rien √† vendre

        if element and element.age >= age_max:
            repo.supprimer(element.identifiant)
            setattr(case, id_attr, None)
            repo_cases.ajouter(case)
            self.argent += element.valeur()
            repo_ressources_joueur.ajouter(self)

    def acheter_graine(self, nom_culture: str, repo=None):
        """
        Ach√®te une graine pour une culture sp√©cifique.

        Args:
            nom_culture (str): Nom de la culture dont acheter la graine.
            repo (object, optional): D√©p√¥t pour mise √† jour.
        """
        self._acheter(nom_culture, self.catalogue_prix.get("graine"), type_de_ressources=self.graines, repo=repo)

    def acheter_animal(self, nom_animal: str, repo=None):
        """
        Ach√®te un animal sp√©cifique.

        Args:
            nom_animal (str): Nom de l'animal √† acheter.
            repo (object, optional): D√©p√¥t pour mise √† jour.
        """        
        self._acheter(nom_animal, self.catalogue_prix.get(nom_animal), type_de_ressources=self.animaux, repo=repo)

    def acheter_batiment(self, nom_batiment: str, repo=None):
        """
        Ach√®te un b√¢timent sp√©cifique.

        Args:
            nom_batiment (str): Nom du b√¢timent √† acheter.
            repo (object, optional): D√©p√¥t pour mise √† jour.
        """
        self._acheter(nom_batiment, self.catalogue_prix.get(nom_batiment), type_de_ressources=self.batiments, repo=repo)

    def acheter_technicien(self, nom_technicien: str, repo_batiments=None, repo_ressources=None):
        """
        Ach√®te un technicien pour r√©parer une panne √©ventuelle ou en ajouter un.

        Args:
            nom_technicien (str): Type de technicien √† acheter.
            repo_batiments (object, optional): D√©p√¥t des b√¢timents (non utilis√© ici).
            repo_ressources (object, optional): D√©p√¥t pour mise √† jour des ressources.
        """
        # 1Ô∏è‚É£ Achat normal
        self._acheter(nom_technicien, self.catalogue_prix.get(nom_technicien), type_de_ressources=self.techniciens, 
                      repo=repo_ressources)
        # 2Ô∏è‚É£ Si une panne globale existe et que le technicien correspond, r√©parer imm√©diatement
        if hasattr(self, 'jeu') and self.jeu.panne_actuelle == nom_technicien:
            if self.techniciens[nom_technicien] > 0:
                self.techniciens[nom_technicien] -= 1
                self.jeu.panne_actuelle = None
                print(f"üîß Panne globale r√©par√©e gr√¢ce au nouveau {nom_technicien} achet√© !")
            else:
                print(f"‚ùå Impossible de r√©parer la panne globale, pas assez de {nom_technicien}.")

    def acheter_eau(self, repo=None):
        """
        Ach√®te une certaine quantit√© d'eau.

        Args:
            repo (object, optional): D√©p√¥t pour mise √† jour.
        """
        quant = self.catalogue_prix._quantite.get("eau", 1)
        self._acheter("eau", prix=self.catalogue_prix.get("eau"), quantite=quant,
                      effet=lambda: setattr(self, "eau", self.eau + quant), repo=repo)

    def acheter_medicament(self, repo=None):
        """
        Ach√®te une certaine quantit√© de m√©dicaments.

        Args:
            repo (object, optional): D√©p√¥t pour mise √† jour.
        """
        quant = self.catalogue_prix._quantite.get("m√©dicament", 1)      
        self._acheter("m√©dicament", prix=self.catalogue_prix.get("m√©dicament"), quantite=quant,
                      effet=lambda: setattr(self, "medicaments", self.medicaments + quant), repo=repo)

    def acheter_nourriture_betails(self, repo=None):
        """
        Ach√®te une certaine quantit√© de nourriture pour le b√©tail.

        Args:
            repo (object, optional): D√©p√¥t pour mise √† jour.
        """
        quant = self.catalogue_prix._quantite.get("nourriture_betails", 1)
        self._acheter("nourriture_betails", prix=self.catalogue_prix.get("nourriture_betails"), quantite=quant,
                      effet=lambda: setattr(self, "nourriture_betails", self.nourriture_betails + quant), repo=repo)

    def recolter(self, case, repo_cultures, repo_animaux, repo_cases, repo_ressources_joueur):
        """
        R√©colte une culture mature d'une case.

        Args:
            case (object): Case √† r√©colter.
            repo_cultures (object): D√©p√¥t des cultures.
            repo_animaux (object): D√©p√¥t des animaux.
            repo_cases (object): D√©p√¥t des cases.
            repo_ressources_joueur (object): D√©p√¥t pour mise √† jour des ressources.
        """
        self._vendre(case, ModeSelection.CULTURE, repo_cultures, repo_animaux, repo_cases, repo_ressources_joueur)

    def vendre_animal(self, case, repo_cultures, repo_animaux, repo_cases, repo_ressources_joueur):
        """
        Vend un animal mature d'une case.

        Args:
            case (object): Case contenant l'animal.
            repo_cultures (object): D√©p√¥t des cultures.
            repo_animaux (object): D√©p√¥t des animaux.
            repo_cases (object): D√©p√¥t des cases.
            repo_ressources_joueur (object): D√©p√¥t pour mise √† jour des ressources.
        """
        self._vendre(case, ModeSelection.ANIMAL, repo_cultures, repo_animaux, repo_cases, repo_ressources_joueur)

    def vendre_batiment(self, batiment_id: str, repo_batiments, repo_cases, repo_ressources_joueur, obtenir_case):
        """
        Vend un b√¢timent en le supprimant du d√©p√¥t et lib√®re ses cases.

        Args:
            batiment_id (str): Identifiant du b√¢timent √† vendre.
            repo_batiments (object): D√©p√¥t des b√¢timents.
            repo_cases (object): D√©p√¥t des cases.
            repo_ressources_joueur (object): D√©p√¥t pour mise √† jour des ressources.
            obtenir_case (callable): Fonction pour obtenir une case par coordonn√©es.
        """
        # R√©cup√®re le b√¢timent √† supprimer
        batiment = repo_batiments.trouver_par_id(batiment_id)
        if not batiment:
            print(f"Aucun b√¢timent avec l'id {batiment_id} trouv√©.")
            return
        # 1Ô∏è‚É£ Lib√®re toutes les cases occup√©es par ce b√¢timent
        for dx in range(batiment.largeur):
            for dy in range(batiment.hauteur):
                case = obtenir_case(batiment.x + dx, batiment.y + dy)
                if case and case.id_batiment == batiment_id:
                    case.id_batiment = None
                    repo_cases.ajouter(case)
        # 2Ô∏è‚É£ Supprime le b√¢timent du d√©p√¥t
        repo_batiments.supprimer(batiment_id)
        # 3Ô∏è‚É£ Ajoute un revenu √† la vente (optionnel)
        revenu = batiment.production_journaliere() * 10  # ex: 10 jours de revenu
        self.argent += revenu
        repo_ressources_joueur.ajouter(self)
        print(f"{batiment.nom()} vendu pour {revenu}‚Ç¨.")

    def calculer_besoin_eau_et_nourriture_batiments(self) -> tuple[float, float]:
        """
        Calcule le besoin total en nourriture et en eau pour tous les b√¢timents existants,
        en tenant compte du type d‚Äôanimal h√©berg√© par chaque b√¢timent.
        
        Returns:
            tuple: Besoin total en nourriture et en eau.
        """
        repo_bat = DepotBatiment()
        liste_batiments = repo_bat.tout_recuperer()
        compteur = {}
        for bat in liste_batiments:
            nom = bat.nom()
            if nom in compteur:
                compteur[nom] += 1
            else:
                compteur[nom] = 1
        total_nourriture = 0.0
        total_eau = 0.0
        for nom_bat, quantite in compteur.items():
            batiments_type = []
            for b in liste_batiments:
                if b.nom() == nom_bat:
                    batiments_type.append(b)
            if batiments_type:
                capacite = batiments_type[0].capacite_animaux()
            else:
                capacite = 0
            # üêë D√©duire le type d‚Äôanimal √† partir du b√¢timent
            if "poulailler" in nom_bat:
                animal = CLASSES_ANIMAUX["poule"](identifiant=generer_identifiant())
            elif "√©table" in nom_bat:
                animal = CLASSES_ANIMAUX["mouton"](identifiant=generer_identifiant())
            elif "laiterie" in nom_bat:
                animal = CLASSES_ANIMAUX["vache"](identifiant=generer_identifiant())
            else:
                animal = None
            if animal:
                besoin_nourriture_par_animal = animal.besoin_nourriture()
                besoin_eau_par_animal = animal.besoin_eau()
            else:
                besoin_nourriture_par_animal = 0.0
                besoin_eau_par_animal = 0.0
            total_nourriture += quantite * capacite * besoin_nourriture_par_animal
            total_eau += quantite * capacite * besoin_eau_par_animal
        return total_nourriture, total_eau

    def calculer_revenu_batiments(self, panne_actuelle=None) -> float:
        """
        Calcule le revenu total g√©n√©r√© par les b√¢timents apr√®s d√©duction des co√ªts d'entretien.

        Args:
            panne_actuelle (str, optional): Type de panne actuelle qui bloque la production.

        Returns:
            float: Revenu net total g√©n√©r√© par les b√¢timents.
        """
        revenu_total = 0.0
        repo_bat = DepotBatiment()
        liste_batiments = repo_bat.tout_recuperer()
        compteur = {}
        for bat in liste_batiments:
            nom = bat.nom()
            if nom in compteur:
                compteur[nom] += 1
            else:
                compteur[nom] = 1
        for nom_bat, quantite in compteur.items():
            produit = PRODUIT_PAR_BATIMENT.get(nom_bat)
            if produit is None:
                continue
            batiments_type = []
            for b in liste_batiments:
                if b.nom() == nom_bat:
                    batiments_type.append(b)
            total_production = 0.0
            for b in batiments_type:
                if panne_actuelle is not None:
                    prod = 0.0
                else:
                    prod = b.production_journaliere()
                total_production += prod
            if batiments_type:
                cout_ent = batiments_type[0].cout_entretien()
            else:
                cout_ent = 0.0
            prix_unitaire = self.catalogue_prix.get(produit)
            revenu_brut = total_production * prix_unitaire
            revenu_net = revenu_brut - quantite * cout_ent
            if revenu_net > 0.0:
                revenu_total += revenu_net
            else:
                revenu_total += 0.0
        return revenu_total
    
    def tomber_en_panne(self, batiment, type_de_de_panne_metier: str):
        """
        D√©clare un b√¢timent en panne et d√©finit le type de technicien requis pour la r√©parer.

        Args:
            batiment (object): B√¢timent √† marquer en panne.
            type_de_de_panne_metier (str): Type de technicien requis pour la r√©paration.

        Raises:
            ValueError: Si le type de panne est inconnu.
        """
        if not batiment.est_en_panne:
            self.est_en_panne = True
            if type_de_de_panne_metier not in ("m√©canicien", "plombier", "√©lectricien"):
                raise ValueError(f"Type de panne inconnue : {type_de_de_panne_metier}")
            batiment.est_en_panne = True
            batiment.type_de_de_panne_metier = type_de_de_panne_metier
            print(f"{self.nom()} en panne ({type_de_de_panne_metier})")

        
    def en_dictionnaire(self) -> Dict[str, object]:
        """
        Convertit l'√©tat actuel des ressources du joueur en dictionnaire.

        Returns:
            dict: Dictionnaire des ressources et de leur valeur actuelle.
        """
        return {
            "identifiant": self.identifiant,
            "argent": self.argent,
            "medicaments": self.medicaments,
            "eau": self.eau,
            "nourriture_betails": self.nourriture_betails,
            "graines": self.graines,
            "animaux": self.animaux,
            "batiments": self.batiments,
            "production_batiments" : self.production_batiments,
            "techniciens": self.techniciens
        }  
